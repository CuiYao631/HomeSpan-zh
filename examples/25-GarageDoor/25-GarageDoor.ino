/*********************************************************************************
 *  MIT License
 *  
 *  Copyright (c) 2020-2024 Gregg E. Berman
 *  
 *  https://github.com/HomeSpan/HomeSpan
 *  
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *  
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 *  
 ********************************************************************************/

////////////////////////////////////////////////////////////
//                                                        //
//    HomeSpan: A HomeKit implementation for the ESP32    //
//    ------------------------------------------------    //
//                                                        //
// ÁÆÄÂçïËΩ¶Â∫ìÈó®Á§∫‰æã                                          //
// Simple Garage Door Example                             //
//                                                        //
////////////////////////////////////////////////////////////

#include "HomeSpan.h"
#include <WiFi.h>
#include <nvs_flash.h>
#include <esp_wifi.h>

// ‰º™‰ª£Á†ÅÔºöÂÆûÈôÖÈ°πÁõÆ‰∏≠ËØ∑Áî®ÁúüÂÆûÁöÑ‰º†ÊÑüÂô®ÂíåÁªßÁîµÂô®ÊéßÂà∂
#define GARAGE_DOOR_RELAY_PIN  12   // ÊéßÂà∂ÁªßÁîµÂô®ÁöÑGPIO
#define GARAGE_DOOR_SENSOR_PIN 14   // Ê£ÄÊµãÈó®Áä∂ÊÄÅÁöÑGPIO
#define RESET_BUTTON_PIN       0    // ÈáçÁΩÆÊåâÈíÆGPIO (ÈÄöÂ∏∏‰ΩøÁî®ÊùøËΩΩÊåâÈíÆ)
#define WIFI_LED_PIN           2    // WiFiÁä∂ÊÄÅLEDÊåáÁ§∫ÁÅØGPIO

struct GarageDoor : Service::GarageDoorOpener {
  SpanCharacteristic *currentState, *targetState, *obstruction;

  GarageDoor() : Service::GarageDoorOpener() {
    currentState = new Characteristic::CurrentDoorState(1); // 1=Closed
    targetState  = new Characteristic::TargetDoorState(1);  // 1=Close, 0=Open
    obstruction  = new Characteristic::ObstructionDetected(false);
    pinMode(GARAGE_DOOR_RELAY_PIN, OUTPUT);
    pinMode(GARAGE_DOOR_SENSOR_PIN, INPUT_PULLUP);
  }

  boolean update() override {
    int tgt = targetState->getNewVal();
    int cur = currentState->getVal();
    if (tgt != cur) {
      // Ëß¶ÂèëÁªßÁîµÂô®ÔºåÊ®°ÊãüÂºÄ/ÂÖ≥Èó®
      digitalWrite(GARAGE_DOOR_RELAY_PIN, LOW);
      delay(500);
      digitalWrite(GARAGE_DOOR_RELAY_PIN, HIGH);

      // ÁÆÄÂçïÊ®°ÊãüÈó®ÁßªÂä®
      currentState->setVal(2); // 2=Opening, 3=Closing
      delay(3000); // ÂÅáËÆæ3ÁßíÂÆåÊàê
      currentState->setVal(tgt == 0 ? 0 : 1); // 0=Open, 1=Closed
    }
    return true;
  }
};

// ÂΩªÂ∫ïÊ∏ÖÈô§WiFiÈÖçÁΩÆÁöÑÂáΩÊï∞
void clearWiFiCompletely() {
  Serial.println("üßπ ÂºÄÂßãÂΩªÂ∫ïÊ∏ÖÈô§WiFiÈÖçÁΩÆ...");
  
  // 1. Êñ≠ÂºÄÂΩìÂâçWiFiËøûÊé•
  WiFi.disconnect(true);
  delay(1000);
  
  // 2. Ê∏ÖÈô§WiFiÊ®°ÂºèÂíåÈÖçÁΩÆ
  WiFi.mode(WIFI_OFF);
  delay(1000);
  
  // 3. Ê∏ÖÈô§ESP32Â≠òÂÇ®ÁöÑWiFiÂá≠ÊçÆ
  esp_wifi_restore();
  delay(1000);
  
  // 4. Ê∏ÖÈô§NVSÂàÜÂå∫‰∏≠ÁöÑWiFiÁõ∏ÂÖ≥Êï∞ÊçÆ
  nvs_flash_erase();
  nvs_flash_init();
  delay(1000);
  
  // 5. ‰ΩøÁî®HomeSpanÁöÑWiFiÈáçÁΩÆ
  homeSpan.processSerialCommand("W");
  delay(1000);
  
  Serial.println("‚úÖ WiFiÈÖçÁΩÆÂ∑≤ÂΩªÂ∫ïÊ∏ÖÈô§!");
  Serial.println("üîÑ ËÆæÂ§áÂç≥Â∞ÜÈáçÂêØ...");
  delay(2000);
  
  // ÈáçÂêØËÆæÂ§á
  ESP.restart();
}

// ÂΩªÂ∫ïÂ∑•ÂéÇÈáçÁΩÆÁöÑÂáΩÊï∞
void factoryResetComplete() {
  Serial.println("üè≠ ÂºÄÂßãÂΩªÂ∫ïÂ∑•ÂéÇÈáçÁΩÆ...");
  
  // 1. Ê∏ÖÈô§WiFiÈÖçÁΩÆ
  WiFi.disconnect(true);
  WiFi.mode(WIFI_OFF);
  esp_wifi_restore();
  delay(1000);
  
  // 2. Ê∏ÖÈô§ÊâÄÊúâNVSÊï∞ÊçÆ
  nvs_flash_erase();
  nvs_flash_init();
  delay(1000);
  
  // 3. ‰ΩøÁî®HomeSpanÁöÑÂ∑•ÂéÇÈáçÁΩÆ
  homeSpan.processSerialCommand("R");
  delay(1000);
  
  Serial.println("‚úÖ Â∑•ÂéÇÈáçÁΩÆÂ∑≤ÂÆåÊàê!");
  Serial.println("üîÑ ËÆæÂ§áÂç≥Â∞ÜÈáçÂêØ...");
  delay(2000);
  
  // ÈáçÂêØËÆæÂ§á
  ESP.restart();
}
// Ê£ÄÊü•ÈáçÁΩÆÊåâÈíÆÁöÑÂáΩÊï∞
void checkResetButton() {
  static unsigned long pressStart = 0;
  static bool lastState = HIGH;
  
  bool currentState = digitalRead(RESET_BUTTON_PIN);
  
  // Ê£ÄÊµãÊåâÈíÆÊåâ‰∏ã
  if (lastState == HIGH && currentState == LOW) {
    pressStart = millis();
    Serial.println("üîò Ê£ÄÊµãÂà∞ÊåâÈíÆÊåâ‰∏ã...");
  }
  
  // Ê£ÄÊµãÊåâÈíÆÈáäÊîæ
  else if (lastState == LOW && currentState == HIGH) {
    unsigned long pressDuration = millis() - pressStart;
    
    if (pressDuration >= 5000 && pressDuration < 10000) {
      // 5-10ÁßíÔºöÂΩªÂ∫ïÈáçÁΩÆWiFiÈÖçÁΩÆ
      Serial.println("üì∂ ÊâßË°åÂΩªÂ∫ïWiFiÈáçÁΩÆ...");
      clearWiFiCompletely();  // Ë∞ÉÁî®ÂΩªÂ∫ïÊ∏ÖÈô§ÂáΩÊï∞
    }
    else if (pressDuration >= 10000) {
      // 10Áßí‰ª•‰∏äÔºöÂΩªÂ∫ïÂ∑•ÂéÇÈáçÁΩÆ
      Serial.println("üè≠ ÊâßË°åÂΩªÂ∫ïÂ∑•ÂéÇÈáçÁΩÆ...");
      factoryResetComplete();  // Ë∞ÉÁî®ÂΩªÂ∫ïÂ∑•ÂéÇÈáçÁΩÆÂáΩÊï∞
    }
    else {
      Serial.printf("‚è±Ô∏è  ÊåâÈíÆÊåâ‰∏ãÊó∂Èó¥: %lu ms (ÈúÄË¶Å5Áßí‰ª•‰∏äÈáçÁΩÆWiFi)\n", pressDuration);
    }
    pressStart = 0;
  }
  
  lastState = currentState;
}

void setup() {
  Serial.begin(115200);
  
  // ÈÖçÁΩÆGPIOÂºïËÑö
  pinMode(RESET_BUTTON_PIN, INPUT_PULLUP);
  pinMode(WIFI_LED_PIN, OUTPUT);
  digitalWrite(WIFI_LED_PIN, LOW);  // ÂàùÂßãÁä∂ÊÄÅLEDÂÖ≥Èó≠
  
  Serial.println("üöÄ HomeSpanËΩ¶Â∫ìÈó®ÊéßÂà∂Âô®ÂêØÂä®‰∏≠...");
  Serial.println("üì° ÈªòËÆ§ÂêØÂä®APÈÖçÁΩëÊ®°Âºè");
  Serial.println("üí° WiFiÁä∂ÊÄÅLED: GPIO2");
  
  // ËÆæÁΩÆHomeSpanÈªòËÆ§ÂêØÂä®APÊ®°Âºè
  // homeSpan.setApSSID("HomeSpan-GarageDoor");           // Ëá™ÂÆö‰πâAPÁÉ≠ÁÇπÂêçÁß∞
  // homeSpan.setApPassword("");                          // Êó†ÂØÜÁ†Å
  // homeSpan.setApTimeout(300);                          // APÊ®°ÂºèË∂ÖÊó∂5ÂàÜÈíü
  homeSpan.enableAutoStartAP();                        // ÂêØÁî®Ëá™Âä®APÊ®°Âºè
  
  
  homeSpan.begin(Category::GarageDoorOpeners, "ËΩ¶Â∫ìÈó®");

  new SpanAccessory();
    new Service::AccessoryInformation();
      new Characteristic::Identify();
      new Characteristic::Name("Garage Door");
      new Characteristic::Manufacturer("HomeSpan");           // Âà∂ÈÄ†ÂïÜ
      new Characteristic::SerialNumber("HS-GD-001");         // Â∫èÂàóÂè∑
      new Characteristic::Model("ESP32 Garage Door");        // ÂûãÂè∑
      new Characteristic::FirmwareRevision("1.0.0");        // Âõ∫‰ª∂ÁâàÊú¨
      new Characteristic::HardwareRevision("1.0");          // Á°¨‰ª∂ÁâàÊú¨
    new GarageDoor();
    
}

void loop() {
  homeSpan.poll();
  checkResetButton();  // Ê£ÄÊü•ÈáçÁΩÆÊåâÈíÆÁä∂ÊÄÅ
  
  // Ê£ÄÊü•WiFiËøûÊé•Áä∂ÊÄÅÂπ∂ÊéßÂà∂LED
  static unsigned long lastCheck = 0;
  static bool wasConnected = false;
  static unsigned long blinkTimer = 0;
  static bool ledState = false;
  
  if (millis() - lastCheck > 1000) {  // ÊØè1ÁßíÊ£ÄÊü•‰∏ÄÊ¨°WiFiÁä∂ÊÄÅ
    lastCheck = millis();
    
    bool isConnected = (WiFi.status() == WL_CONNECTED);
    
    if (isConnected && !wasConnected) {
      // WiFiÂàöËøûÊé•ÊàêÂäü
      Serial.println("‚úÖ WiFiËøûÊé•ÊàêÂäü!");
      Serial.printf("üì∂ Â∑≤ËøûÊé•Âà∞: %s\n", WiFi.SSID().c_str());
      Serial.printf("üåê IPÂú∞ÂùÄ: %s\n", WiFi.localIP().toString().c_str());
      digitalWrite(WIFI_LED_PIN, HIGH);  // ÁÇπ‰∫ÆLED
    }
    else if (!isConnected && wasConnected) {
      // WiFiËøûÊé•‰∏¢Â§±
      Serial.println("‚ö†Ô∏è  WiFiËøûÊé•‰∏¢Â§±ÔºÅ");
      Serial.println("üì° Ëá™Âä®ÂêØÂä®APÈÖçÁΩëÊ®°Âºè...");
      digitalWrite(WIFI_LED_PIN, LOW);   // ÂÖ≥Èó≠LED
      delay(2000);
      homeSpan.processSerialCommand("A");
    }
    
    wasConnected = isConnected;
  }
  
  // WiFiËøûÊé•‰∏≠Êó∂LEDÈó™ÁÉÅÊïàÊûú
  if (WiFi.status() != WL_CONNECTED) {
    if (millis() - blinkTimer > 500) {  // ÊØè500msÈó™ÁÉÅ‰∏ÄÊ¨°
      blinkTimer = millis();
      ledState = !ledState;
      digitalWrite(WIFI_LED_PIN, ledState);
    }
  }
}
